#pragma kernel ClearGrid
#pragma kernel TransferToGrid
#pragma kernel NormalizeGrid
#pragma kernel ComputeDivergence
#pragma kernel JacobiPressure
#pragma kernel SubtractPressureGradient
#pragma kernel GridToParticles
#pragma kernel AdvectVelocity

// Buffers
RWStructuredBuffer<int3> gridVelocityInt;
RWStructuredBuffer<float3> gridVelocityFloat;
RWStructuredBuffer<uint> gridWeight;

RWStructuredBuffer<float3> particlePositions;
RWStructuredBuffer<float3> particleVelocities;

RWStructuredBuffer<float> divergence;
RWStructuredBuffer<float> pressure;
RWStructuredBuffer<float> pressureTemp; 

int numJacobiIterations = 40;

// Parameters
int gridSizeX;
int gridSizeY;
int gridSizeZ;
int particleCount;
float dt;
float cellSize;
float flipRatio;
float3 gravity;

// NEW: Add particleCollisionRadius parameter
float particleCollisionRadius;

#define FP_SCALE 1000.0

// Helper function
int GetIndex(int x, int y, int z)
{
    return x + y * gridSizeX + z * gridSizeX * gridSizeZ;
}

[numthreads(8, 8, 4)]
void ClearGrid(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;
    uint z = id.z;
    
    if (x >= gridSizeX || y >= gridSizeY || z >= gridSizeZ) 
        return;
    
    int index = GetIndex(x, y, z);
    gridVelocityInt[index] = int3(0, 0, 0);
    gridVelocityFloat[index] = float3(0, 0, 0);
    gridWeight[index] = 0;
    divergence[index] = 0.0;
    pressure[index] = 0.0;
    pressureTemp[index] = 0.0;
}

[numthreads(256, 1, 1)]
void TransferToGrid(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount) 
        return;
    
    float3 pos = particlePositions[i];
    float3 vel = particleVelocities[i];
    
    // Convert to grid cell
    int3 cell = (int3)floor(pos / cellSize);
    cell.x = clamp(cell.x, 0, gridSizeX - 1);
    cell.y = clamp(cell.y, 0, gridSizeY - 1);
    cell.z = clamp(cell.z, 0, gridSizeZ - 1);
    
    int index = GetIndex(cell.x, cell.y, cell.z);
    
    // Add to grid
    InterlockedAdd(gridVelocityInt[index].x, (int)(vel.x * FP_SCALE));
    InterlockedAdd(gridVelocityInt[index].y, (int)(vel.y * FP_SCALE));
    InterlockedAdd(gridVelocityInt[index].z, (int)(vel.z * FP_SCALE));
    InterlockedAdd(gridWeight[index], 1);
}

[numthreads(8, 8, 4)]
void NormalizeGrid(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;
    uint z = id.z;
    
    if (x >= gridSizeX || y >= gridSizeY || z >= gridSizeZ)
        return;
    
    int index = GetIndex(x, y, z);
    
    uint weight = gridWeight[index];
    
    if (weight > 0)
    {
        float invW = 1.0 / (float)weight;
        float3 vel = float3(
            (float)gridVelocityInt[index].x,
            (float)gridVelocityInt[index].y,
            (float)gridVelocityInt[index].z
        ) * invW / FP_SCALE;
        
        // Add gravity
        vel += gravity * dt;
        
        gridVelocityFloat[index] = vel;
    }
    else
    {
        gridVelocityFloat[index] = gravity * dt;
    }
}

[numthreads(8, 8, 4)]
void AdvectVelocity(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;
    uint z = id.z;
    
    if (x >= gridSizeX || y >= gridSizeY || z >= gridSizeZ)
        return;

    int idx = GetIndex(x, y, z);
    
    // Get velocity at current cell
    float3 vel = gridVelocityFloat[idx];
    
    // Trace back in time (semi-Lagrangian advection)
    float3 tracePos = float3(x, y, z) - vel * dt / cellSize;
    
    // Clamp to grid bounds
    tracePos.x = clamp(tracePos.x, 0.5f, gridSizeX - 0.5f);
    tracePos.y = clamp(tracePos.y, 0.5f, gridSizeY - 0.5f);
    tracePos.z = clamp(tracePos.z, 0.5f, gridSizeZ - 0.5f);
    
    // Sample velocity at traced position (trilinear interpolation)
    int3 cell = (int3)floor(tracePos);
    float3 frac = tracePos - float3(cell);
    
    // Get indices for 8 surrounding cells
    int idx000 = GetIndex(cell.x, cell.y, cell.z);
    int idx100 = GetIndex(cell.x + 1, cell.y, cell.z);
    int idx010 = GetIndex(cell.x, cell.y + 1, cell.z);
    int idx110 = GetIndex(cell.x + 1, cell.y + 1, cell.z);
    int idx001 = GetIndex(cell.x, cell.y, cell.z + 1);
    int idx101 = GetIndex(cell.x + 1, cell.y, cell.z + 1);
    int idx011 = GetIndex(cell.x, cell.y + 1, cell.z + 1);
    int idx111 = GetIndex(cell.x + 1, cell.y + 1, cell.z + 1);
    
    // Get velocities
    float3 v000 = gridVelocityFloat[idx000];
    float3 v100 = gridVelocityFloat[idx100];
    float3 v010 = gridVelocityFloat[idx010];
    float3 v110 = gridVelocityFloat[idx110];
    float3 v001 = gridVelocityFloat[idx001];
    float3 v101 = gridVelocityFloat[idx101];
    float3 v011 = gridVelocityFloat[idx011];
    float3 v111 = gridVelocityFloat[idx111];
    
    // Trilinear interpolation
    float3 advectedVel = 
        v000 * (1 - frac.x) * (1 - frac.y) * (1 - frac.z) +
        v100 * frac.x * (1 - frac.y) * (1 - frac.z) +
        v010 * (1 - frac.x) * frac.y * (1 - frac.z) +
        v110 * frac.x * frac.y * (1 - frac.z) +
        v001 * (1 - frac.x) * (1 - frac.y) * frac.z +
        v101 * frac.x * (1 - frac.y) * frac.z +
        v011 * (1 - frac.x) * frac.y * frac.z +
        v111 * frac.x * frac.y * frac.z;
    
    // Update velocity with advection
    gridVelocityFloat[idx] = advectedVel;
}

[numthreads(8, 8, 4)]
void ComputeDivergence(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;
    uint z = id.z;
    
    if (x >= gridSizeX || y >= gridSizeY || z >= gridSizeZ)
        return;

    int idx = GetIndex(x, y, z);
    
    // Get velocities from neighboring cells
    float3 vL = (x > 0) ? gridVelocityFloat[GetIndex(x-1, y, z)] : float3(0, 0, 0);
    float3 vR = (x < gridSizeX - 1) ? gridVelocityFloat[GetIndex(x+1, y, z)] : float3(0, 0, 0);
    float3 vD = (y > 0) ? gridVelocityFloat[GetIndex(x, y-1, z)] : float3(0, 0, 0);
    float3 vU = (y < gridSizeY - 1) ? gridVelocityFloat[GetIndex(x, y+1, z)] : float3(0, 0, 0);
    float3 vB = (z > 0) ? gridVelocityFloat[GetIndex(x, y, z-1)] : float3(0, 0, 0);
    float3 vF = (z < gridSizeZ - 1) ? gridVelocityFloat[GetIndex(x, y, z+1)] : float3(0, 0, 0);
    
    // Compute divergence (how much fluid is expanding/contracting at this point)
    float div = (vR.x - vL.x + vU.y - vD.y + vF.z - vB.z) / (2.0 * cellSize);
    divergence[idx] = div;
}

[numthreads(8, 8, 4)]
void JacobiPressure(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;
    uint z = id.z;
    
    if (x >= gridSizeX || y >= gridSizeY || z >= gridSizeZ)
        return;

    int idx = GetIndex(x, y, z);
    
    // Get pressures from neighboring cells
    float pL = (x > 0) ? pressure[GetIndex(x-1, y, z)] : 0.0;
    float pR = (x < gridSizeX - 1) ? pressure[GetIndex(x+1, y, z)] : 0.0;
    float pD = (y > 0) ? pressure[GetIndex(x, y-1, z)] : 0.0;
    float pU = (y < gridSizeY - 1) ? pressure[GetIndex(x, y+1, z)] : 0.0;
    float pB = (z > 0) ? pressure[GetIndex(x, y, z-1)] : 0.0;
    float pF = (z < gridSizeZ - 1) ? pressure[GetIndex(x, y, z+1)] : 0.0;
    
    float div = divergence[idx];
    
    // Jacobi iteration: solve for pressure that makes velocity divergence-free
    pressureTemp[idx] = (pL + pR + pD + pU + pB + pF - div * cellSize * cellSize) / 6.0;
}

[numthreads(8, 8, 4)]
void SubtractPressureGradient(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;
    uint z = id.z;
    
    if (x >= gridSizeX || y >= gridSizeY || z >= gridSizeZ)
        return;

    int idx = GetIndex(x, y, z);
    
    // Get pressures from neighboring cells
    float pL = (x > 0) ? pressure[GetIndex(x-1, y, z)] : 0.0;
    float pR = (x < gridSizeX - 1) ? pressure[GetIndex(x+1, y, z)] : 0.0;
    float pD = (y > 0) ? pressure[GetIndex(x, y-1, z)] : 0.0;
    float pU = (y < gridSizeY - 1) ? pressure[GetIndex(x, y+1, z)] : 0.0;
    float pB = (z > 0) ? pressure[GetIndex(x, y, z-1)] : 0.0;
    float pF = (z < gridSizeZ - 1) ? pressure[GetIndex(x, y, z+1)] : 0.0;
    
    // Compute pressure gradient
    float3 gradP;
    gradP.x = (pR - pL) / (2.0 * cellSize);
    gradP.y = (pU - pD) / (2.0 * cellSize);
    gradP.z = (pF - pB) / (2.0 * cellSize);
    
    // Subtract pressure gradient from velocity
    gridVelocityFloat[idx] = gridVelocityFloat[idx] - gradP;
}

[numthreads(256, 1, 1)]
void GridToParticles(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;
    
    float3 pos = particlePositions[i];
    float3 vel = particleVelocities[i];
    
    // Convert to grid space for velocity sampling
    float3 gridPos = pos / cellSize;
    
    // TRILINEAR INTERPOLATION
    int3 cell = (int3)floor(gridPos);
    float3 frac = gridPos - float3(cell);
    
    // Get indices for 8 surrounding cells
    int idx000 = GetIndex(cell.x, cell.y, cell.z);
    int idx100 = GetIndex(cell.x + 1, cell.y, cell.z);
    int idx010 = GetIndex(cell.x, cell.y + 1, cell.z);
    int idx110 = GetIndex(cell.x + 1, cell.y + 1, cell.z);
    int idx001 = GetIndex(cell.x, cell.y, cell.z + 1);
    int idx101 = GetIndex(cell.x + 1, cell.y, cell.z + 1);
    int idx011 = GetIndex(cell.x, cell.y + 1, cell.z + 1);
    int idx111 = GetIndex(cell.x + 1, cell.y + 1, cell.z + 1);
    
    // Get velocities
    float3 v000 = gridVelocityFloat[idx000];
    float3 v100 = gridVelocityFloat[idx100];
    float3 v010 = gridVelocityFloat[idx010];
    float3 v110 = gridVelocityFloat[idx110];
    float3 v001 = gridVelocityFloat[idx001];
    float3 v101 = gridVelocityFloat[idx101];
    float3 v011 = gridVelocityFloat[idx011];
    float3 v111 = gridVelocityFloat[idx111];
    
    // Trilinear interpolation
    float3 gridVel = 
        v000 * (1 - frac.x) * (1 - frac.y) * (1 - frac.z) +
        v100 * frac.x * (1 - frac.y) * (1 - frac.z) +
        v010 * (1 - frac.x) * frac.y * (1 - frac.z) +
        v110 * frac.x * frac.y * (1 - frac.z) +
        v001 * (1 - frac.x) * (1 - frac.y) * frac.z +
        v101 * frac.x * (1 - frac.y) * frac.z +
        v011 * (1 - frac.x) * frac.y * frac.z +
        v111 * frac.x * frac.y * frac.z;
    
    // FLIP update: blend between PIC (grid velocity) and FLIP (velocity difference)
    float3 deltaVel = gridVel - vel;
    vel += flipRatio * deltaVel;
    
    // Update position with semi-implicit Euler
    pos += vel * dt;
    
    // Boundary collisions
    float margin = particleCollisionRadius;
    float bounce = 0.5f;
    float friction = 0.95f;
    
    if (pos.y < margin) 
    { 
        pos.y = margin; 
        vel.y = abs(vel.y) * bounce;
        vel.x *= friction;
        vel.z *= friction;
    }
    if (pos.y > gridSizeY * cellSize - margin) 
    { 
        pos.y = gridSizeY * cellSize - margin; 
        vel.y = -abs(vel.y) * bounce;
        vel.x *= friction;
        vel.z *= friction;
    }
    // Add x and z boundaries
    if (pos.x < margin) { pos.x = margin; vel.x = abs(vel.x) * bounce; vel.y *= friction; vel.z *= friction; }
    if (pos.x > gridSizeX * cellSize - margin) { pos.x = gridSizeX * cellSize - margin; vel.x = -abs(vel.x) * bounce; vel.y *= friction; vel.z *= friction; }
    if (pos.z < margin) { pos.z = margin; vel.z = abs(vel.z) * bounce; vel.x *= friction; vel.y *= friction; }
    if (pos.z > gridSizeZ * cellSize - margin) { pos.z = gridSizeZ * cellSize - margin; vel.z = -abs(vel.z) * bounce; vel.x *= friction; vel.y *= friction; }
    
    particleVelocities[i] = vel;
    particlePositions[i] = pos;
}