#pragma kernel ClearGrid
#pragma kernel TransferToGrid
#pragma kernel NormalizeGrid
#pragma kernel ComputeDivergence
#pragma kernel JacobiPressure
#pragma kernel SubtractPressureGradient
#pragma kernel GridToParticles
#pragma kernel AdvectVelocity

// Buffers
RWStructuredBuffer<int3> gridVelocityInt;
RWStructuredBuffer<float3> gridVelocityFloat;
RWStructuredBuffer<uint> gridWeight;

RWStructuredBuffer<float3> particlePositions;
RWStructuredBuffer<float3> particleVelocities;

RWStructuredBuffer<float> divergence;
RWStructuredBuffer<float> pressure;
RWStructuredBuffer<float> pressureTemp; 

int numJacobiIterations = 40;

// Parâmetros
uint gridSizeX;
uint gridSizeY;
uint gridSizeZ;
uint particleCount;
float dt;
float cellSize;
float flipRatio;
float3 gravity;

// Raio de colisão das partículas
float particleCollisionRadius;

// Limites da simulação (definidos no ParticleManager)
float simulationWidth;
float simulationHeight;
float gridHeight;

#define FP_SCALE 1000.0

// Função auxiliar para obter índice na grelha
uint GetIndex(uint x, uint y, uint z)
{
    return x + y * gridSizeX + z * gridSizeX * gridSizeZ;
}

// Limpar todos os buffers da grelha
[numthreads(8, 8, 4)]
void ClearGrid(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;
    uint z = id.z;
    
    if (x >= gridSizeX || y >= gridSizeY || z >= gridSizeZ) 
        return;
    
    uint index = GetIndex(x, y, z);
    gridVelocityInt[index] = int3(0, 0, 0);
    gridVelocityFloat[index] = float3(0, 0, 0);
    gridWeight[index] = 0;
    divergence[index] = 0.0;
    pressure[index] = 0.0;
    pressureTemp[index] = 0.0;
}

// Transferir velocidades das partículas para a grelha
[numthreads(256, 1, 1)]
void TransferToGrid(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount) 
        return;
    
    float3 pos = particlePositions[i];
    float3 vel = particleVelocities[i];
    
    // Converter para célula da grelha
    int3 cell = (int3)floor(pos / cellSize);
    cell.x = clamp(cell.x, 0, (int)gridSizeX - 1);
    cell.y = clamp(cell.y, 0, (int)gridSizeY - 1);
    cell.z = clamp(cell.z, 0, (int)gridSizeZ - 1);
    
    uint index = GetIndex(cell.x, cell.y, cell.z);
    
    // Adicionar à grelha com operações atómicas
    InterlockedAdd(gridVelocityInt[index].x, (int)(vel.x * FP_SCALE));
    InterlockedAdd(gridVelocityInt[index].y, (int)(vel.y * FP_SCALE));
    InterlockedAdd(gridVelocityInt[index].z, (int)(vel.z * FP_SCALE));
    InterlockedAdd(gridWeight[index], 1);
}

// Normalizar velocidades da grelha baseadas nos pesos
[numthreads(8, 8, 4)]
void NormalizeGrid(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;
    uint z = id.z;
    
    if (x >= gridSizeX || y >= gridSizeY || z >= gridSizeZ)
        return;
    
    uint index = GetIndex(x, y, z);
    
    uint weight = gridWeight[index];
    
    if (weight > 0)
    {
        float invW = 1.0 / (float)weight;
        float3 vel = float3(
            (float)gridVelocityInt[index].x,
            (float)gridVelocityInt[index].y,
            (float)gridVelocityInt[index].z
        ) * invW / FP_SCALE;
        
        // Adicionar gravidade
        vel += gravity * dt;
        
        gridVelocityFloat[index] = vel;
    }
    else
    {
        gridVelocityFloat[index] = gravity * dt;
    }
}

// Advectar velocidades usando método semi-Lagrangiano
[numthreads(8, 8, 4)]
void AdvectVelocity(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;
    uint z = id.z;
    
    if (x >= gridSizeX || y >= gridSizeY || z >= gridSizeZ)
        return;

    uint idx = GetIndex(x, y, z);
    
    // Obter velocidade na célula atual
    float3 vel = gridVelocityFloat[idx];
    
    // Traçar para trás no tempo (advecção semi-Lagrangiana)
    float3 tracePos = float3(x, y, z) - vel * dt / cellSize;
    
    // Limitar aos limites da grelha
    tracePos.x = clamp(tracePos.x, 0.5f, gridSizeX - 0.5f);
    tracePos.y = clamp(tracePos.y, 0.5f, gridSizeY - 0.5f);
    tracePos.z = clamp(tracePos.z, 0.5f, gridSizeZ - 0.5f);
    
    // Amostrar velocidade na posição traçada (interpolação trilinear)
    int3 cell = (int3)floor(tracePos);
    float3 frac = tracePos - float3(cell);
    
    // Limitar índices das células
    cell.x = clamp(cell.x, 0, (int)gridSizeX - 1);
    cell.y = clamp(cell.y, 0, (int)gridSizeY - 1);
    cell.z = clamp(cell.z, 0, (int)gridSizeZ - 1);
    
    // Obter índices para as 8 células circundantes
    uint idx000 = GetIndex(cell.x, cell.y, cell.z);
    uint idx100 = GetIndex(min(cell.x + 1, (int)gridSizeX - 1), cell.y, cell.z);
    uint idx010 = GetIndex(cell.x, min(cell.y + 1, (int)gridSizeY - 1), cell.z);
    uint idx110 = GetIndex(min(cell.x + 1, (int)gridSizeX - 1), min(cell.y + 1, (int)gridSizeY - 1), cell.z);
    uint idx001 = GetIndex(cell.x, cell.y, min(cell.z + 1, (int)gridSizeZ - 1));
    uint idx101 = GetIndex(min(cell.x + 1, (int)gridSizeX - 1), cell.y, min(cell.z + 1, (int)gridSizeZ - 1));
    uint idx011 = GetIndex(cell.x, min(cell.y + 1, (int)gridSizeY - 1), min(cell.z + 1, (int)gridSizeZ - 1));
    uint idx111 = GetIndex(min(cell.x + 1, (int)gridSizeX - 1), min(cell.y + 1, (int)gridSizeY - 1), min(cell.z + 1, (int)gridSizeZ - 1));
    
    // Obter velocidades
    float3 v000 = gridVelocityFloat[idx000];
    float3 v100 = gridVelocityFloat[idx100];
    float3 v010 = gridVelocityFloat[idx010];
    float3 v110 = gridVelocityFloat[idx110];
    float3 v001 = gridVelocityFloat[idx001];
    float3 v101 = gridVelocityFloat[idx101];
    float3 v011 = gridVelocityFloat[idx011];
    float3 v111 = gridVelocityFloat[idx111];
    
    // Interpolação trilinear
    float3 advectedVel = 
        v000 * (1 - frac.x) * (1 - frac.y) * (1 - frac.z) +
        v100 * frac.x * (1 - frac.y) * (1 - frac.z) +
        v010 * (1 - frac.x) * frac.y * (1 - frac.z) +
        v110 * frac.x * frac.y * (1 - frac.z) +
        v001 * (1 - frac.x) * (1 - frac.y) * frac.z +
        v101 * frac.x * (1 - frac.y) * frac.z +
        v011 * (1 - frac.x) * frac.y * frac.z +
        v111 * frac.x * frac.y * frac.z;
    
    // Atualizar velocidade com advecção
    gridVelocityFloat[idx] = advectedVel;
}

// Calcular divergência do campo de velocidades
[numthreads(8, 8, 4)]
void ComputeDivergence(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;
    uint z = id.z;
    
    if (x >= gridSizeX || y >= gridSizeY || z >= gridSizeZ)
        return;

    uint idx = GetIndex(x, y, z);
    
    // Obter velocidades das células vizinhas
    float3 vL = (x > 0) ? gridVelocityFloat[GetIndex(x-1, y, z)] : float3(0, 0, 0);
    float3 vR = (x < gridSizeX - 1) ? gridVelocityFloat[GetIndex(x+1, y, z)] : float3(0, 0, 0);
    float3 vD = (y > 0) ? gridVelocityFloat[GetIndex(x, y-1, z)] : float3(0, 0, 0);
    float3 vU = (y < gridSizeY - 1) ? gridVelocityFloat[GetIndex(x, y+1, z)] : float3(0, 0, 0);
    float3 vB = (z > 0) ? gridVelocityFloat[GetIndex(x, y, z-1)] : float3(0, 0, 0);
    float3 vF = (z < gridSizeZ - 1) ? gridVelocityFloat[GetIndex(x, y, z+1)] : float3(0, 0, 0);
    
    // Calcular divergência (medida de expansão/contração do fluido)
    float div = (vR.x - vL.x + vU.y - vD.y + vF.z - vB.z) / (2.0 * cellSize);
    divergence[idx] = div;
}

// Iteração de Jacobi para resolver equação de pressão
[numthreads(8, 8, 4)]
void JacobiPressure(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;
    uint z = id.z;
    
    if (x >= gridSizeX || y >= gridSizeY || z >= gridSizeZ)
        return;

    uint idx = GetIndex(x, y, z);
    
    // Obter pressões das células vizinhas
    float pL = (x > 0) ? pressure[GetIndex(x-1, y, z)] : 0.0;
    float pR = (x < gridSizeX - 1) ? pressure[GetIndex(x+1, y, z)] : 0.0;
    float pD = (y > 0) ? pressure[GetIndex(x, y-1, z)] : 0.0;
    float pU = (y < gridSizeY - 1) ? pressure[GetIndex(x, y+1, z)] : 0.0;
    float pB = (z > 0) ? pressure[GetIndex(x, y, z-1)] : 0.0;
    float pF = (z < gridSizeZ - 1) ? pressure[GetIndex(x, y, z+1)] : 0.0;
    
    float div = divergence[idx];
    
    // Iteração de Jacobi: resolver pressão para tornar a velocidade livre de divergência
    pressureTemp[idx] = (pL + pR + pD + pU + pB + pF - div * cellSize * cellSize) / 6.0;
}

// Subtrair gradiente de pressão das velocidades
[numthreads(8, 8, 4)]
void SubtractPressureGradient(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;
    uint z = id.z;
    
    if (x >= gridSizeX || y >= gridSizeY || z >= gridSizeZ)
        return;

    uint idx = GetIndex(x, y, z);
    
    // Obter pressões das células vizinhas
    float pL = (x > 0) ? pressure[GetIndex(x-1, y, z)] : 0.0;
    float pR = (x < gridSizeX - 1) ? pressure[GetIndex(x+1, y, z)] : 0.0;
    float pD = (y > 0) ? pressure[GetIndex(x, y-1, z)] : 0.0;
    float pU = (y < gridSizeY - 1) ? pressure[GetIndex(x, y+1, z)] : 0.0;
    float pB = (z > 0) ? pressure[GetIndex(x, y, z-1)] : 0.0;
    float pF = (z < gridSizeZ - 1) ? pressure[GetIndex(x, y, z+1)] : 0.0;
    
    // Calcular gradiente de pressão
    float3 gradP;
    gradP.x = (pR - pL) / (2.0 * cellSize);
    gradP.y = (pU - pD) / (2.0 * cellSize);
    gradP.z = (pF - pB) / (2.0 * cellSize);
    
    // Subtrair gradiente de pressão da velocidade
    gridVelocityFloat[idx] = gridVelocityFloat[idx] - gradP;
}

// Transferir velocidades da grelha para as partículas
[numthreads(256, 1, 1)]
void GridToParticles(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= particleCount)
        return;
    
    float3 pos = particlePositions[i];
    float3 vel = particleVelocities[i];
    
    // Converter para espaço da grelha para amostragem de velocidade
    float3 gridPos = pos / cellSize;
    
    // Interpolação trilinear
    int3 cell = (int3)floor(gridPos);
    float3 frac = gridPos - float3(cell);
    
    // Limitar índices das células aos limites da grelha
    cell.x = clamp(cell.x, 0, (int)gridSizeX - 1);
    cell.y = clamp(cell.y, 0, (int)gridSizeY - 1);
    cell.z = clamp(cell.z, 0, (int)gridSizeZ - 1);
    
    // Obter índices para 8 células com verificação de limites
    uint idx000 = GetIndex(cell.x, cell.y, cell.z);
    uint idx100 = GetIndex(min(cell.x + 1, (int)gridSizeX - 1), cell.y, cell.z);
    uint idx010 = GetIndex(cell.x, min(cell.y + 1, (int)gridSizeY - 1), cell.z);
    uint idx110 = GetIndex(min(cell.x + 1, (int)gridSizeX - 1), min(cell.y + 1, (int)gridSizeY - 1), cell.z);
    uint idx001 = GetIndex(cell.x, cell.y, min(cell.z + 1, (int)gridSizeZ - 1));
    uint idx101 = GetIndex(min(cell.x + 1, (int)gridSizeX - 1), cell.y, min(cell.z + 1, (int)gridSizeZ - 1));
    uint idx011 = GetIndex(cell.x, min(cell.y + 1, (int)gridSizeY - 1), min(cell.z + 1, (int)gridSizeZ - 1));
    uint idx111 = GetIndex(min(cell.x + 1, (int)gridSizeX - 1), min(cell.y + 1, (int)gridSizeY - 1), min(cell.z + 1, (int)gridSizeZ - 1));
    
    // Obter velocidades
    float3 v000 = gridVelocityFloat[idx000];
    float3 v100 = gridVelocityFloat[idx100];
    float3 v010 = gridVelocityFloat[idx010];
    float3 v110 = gridVelocityFloat[idx110];
    float3 v001 = gridVelocityFloat[idx001];
    float3 v101 = gridVelocityFloat[idx101];
    float3 v011 = gridVelocityFloat[idx011];
    float3 v111 = gridVelocityFloat[idx111];
    
    // Interpolação trilinear
    float3 gridVel = 
        v000 * (1 - frac.x) * (1 - frac.y) * (1 - frac.z) +
        v100 * frac.x * (1 - frac.y) * (1 - frac.z) +
        v010 * (1 - frac.x) * frac.y * (1 - frac.z) +
        v110 * frac.x * frac.y * (1 - frac.z) +
        v001 * (1 - frac.x) * (1 - frac.y) * frac.z +
        v101 * frac.x * (1 - frac.y) * frac.z +
        v011 * (1 - frac.x) * frac.y * frac.z +
        v111 * frac.x * frac.y * frac.z;
    
    // Misturar entre PIC (velocidade da grelha) e FLIP (diferença de velocidade)
    float3 deltaVel = gridVel - vel;
    vel += flipRatio * deltaVel;
    
    // Atualizar posição com Euler semi-implícito
    pos += vel * dt;
    
    // Tratar colisões com os limites da simulação
    float margin = particleCollisionRadius;
    float bounce = 0.5f;
    float friction = 0.95f;
    
    // Paredes em X
    if (pos.x < margin)
    {
        pos.x = margin;
        vel.x = abs(vel.x) * bounce;
        vel.y *= friction;
        vel.z *= friction;
    }
    else if (pos.x > simulationWidth - margin)
    {
        pos.x = simulationWidth - margin;
        vel.x = -abs(vel.x) * bounce;
        vel.y *= friction;
        vel.z *= friction;
    }
    
    // Paredes em Y (chão e teto)
    if (pos.y < margin)
    {
        pos.y = margin;
        vel.y = abs(vel.y) * bounce;
        vel.x *= friction;
        vel.z *= friction;
    }
    else if (pos.y > gridHeight - margin)
    {
        pos.y = gridHeight - margin;
        vel.y = -abs(vel.y) * bounce;
        vel.x *= friction;
        vel.z *= friction;
    }
    
    // Paredes em Z
    if (pos.z < margin)
    {
        pos.z = margin;
        vel.z = abs(vel.z) * bounce;
        vel.x *= friction;
        vel.y *= friction;
    }
    else if (pos.z > simulationHeight - margin)
    {
        pos.z = simulationHeight - margin;
        vel.z = -abs(vel.z) * bounce;
        vel.x *= friction;
        vel.y *= friction;
    }
    
    particleVelocities[i] = vel;
    particlePositions[i] = pos;
}