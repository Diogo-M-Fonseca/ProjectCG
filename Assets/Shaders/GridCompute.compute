#pragma kernel ClearGrid
#pragma kernel TransferToGrid
#pragma kernel NormalizeGrid

RWStructuredBuffer<float> gridDensity;
RWStructuredBuffer<float3> gridVelocity;
RWStructuredBuffer<float> gridWeight;

StructuredBuffer<float3> particlePositions;
StructuredBuffer<float3> particleVelocities;

int gridSizeX;
int gridSizeY;
int gridSizeZ;
uint particleCount;
float particleMass;

// Clear grid buffers
[numthreads(8, 8, 4)]
void ClearGrid(uint3 id : SV_DispatchThreadID) {
    uint x = id.x;
    uint y = id.y;
    uint z = id.z;
    
    if (x >= gridSizeX || y >= gridSizeY || z >= gridSizeZ) return;
    
    int index = (int)(x + y * gridSizeX + z * gridSizeX * gridSizeY);
    gridDensity[index] = 0.0f;
    gridVelocity[index] = float3(0, 0, 0);
    gridWeight[index] = 0.0f;
}

// Transfer particles to grid with trilinear interpolation
[numthreads(256, 1, 1)]
void TransferToGrid(uint3 id : SV_DispatchThreadID) {
    uint i = id.x;
    if (i >= particleCount) return;
    
    float3 pos = particlePositions[i];
    float3 vel = particleVelocities[i];
    
    int x0 = (int)floor(pos.x);
    int y0 = (int)floor(pos.y);
    int z0 = (int)floor(pos.z);
    
    float tx = pos.x - x0;
    float ty = pos.y - y0;
    float tz = pos.z - z0;
    
    // Calculate weights for 8 neighboring cells
    float w000 = (1 - tx) * (1 - ty) * (1 - tz);
    float w100 = tx * (1 - ty) * (1 - tz);
    float w010 = (1 - tx) * ty * (1 - tz);
    float w110 = tx * ty * (1 - tz);
    float w001 = (1 - tx) * (1 - ty) * tz;
    float w101 = tx * (1 - ty) * tz;
    float w011 = (1 - tx) * ty * tz;
    float w111 = tx * ty * tz;
    
    float3 velContrib = vel * particleMass;
    
    // Distribute to 8 neighboring cells
    DistributeToCell(x0, y0, z0, w000, velContrib);
    DistributeToCell(x0 + 1, y0, z0, w100, velContrib);
    DistributeToCell(x0, y0 + 1, z0, w010, velContrib);
    DistributeToCell(x0 + 1, y0 + 1, z0, w110, velContrib);
    DistributeToCell(x0, y0, z0 + 1, w001, velContrib);
    DistributeToCell(x0 + 1, y0, z0 + 1, w101, velContrib);
    DistributeToCell(x0, y0 + 1, z0 + 1, w011, velContrib);
    DistributeToCell(x0 + 1, y0 + 1, z0 + 1, w111, velContrib);
}

void DistributeToCell(int x, int y, int z, float weight, float3 velContrib) {
    if (x < 0 || x >= gridSizeX || y < 0 || y >= gridSizeY || z < 0 || z >= gridSizeZ) return;
    
    int index = x + y * gridSizeX + z * gridSizeX * gridSizeY;
    
    // Atomic operations for thread safety
    float dummy;
    InterlockedAdd(gridWeight[index], weight, dummy);
    
    // For velocity, we need to do it component-wise
    float oldX, oldY, oldZ;
    InterlockedAdd(gridVelocity[index].x, velContrib.x * weight, oldX);
    InterlockedAdd(gridVelocity[index].y, velContrib.y * weight, oldY);
    InterlockedAdd(gridVelocity[index].z, velContrib.z * weight, oldZ);
    
    // Density contribution
    InterlockedAdd(gridDensity[index], weight * particleMass, dummy);
}

// Normalize grid values by weight
[numthreads(8, 8, 4)]
void NormalizeGrid(uint3 id : SV_DispatchThreadID) {
    uint x = id.x;
    uint y = id.y;
    uint z = id.z;
    
    if (x >= gridSizeX || y >= gridSizeY || z >= gridSizeZ) return;
    
    int index = (int)(x + y * gridSizeX + z * gridSizeX * gridSizeY);
    float weight = gridWeight[index];
    
    if (weight > 0.0001f) {
        gridVelocity[index] = gridVelocity[index] / weight;
        gridDensity[index] = gridDensity[index] / weight;
    }
}