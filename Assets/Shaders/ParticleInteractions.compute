#pragma kernel BuildSpatialGrid
#pragma kernel FindNeighbors
#pragma kernel ComputeDensity
#pragma kernel ComputeForces
#pragma kernel ApplyForces

// Buffers
RWStructuredBuffer<float3> particlePositions;
RWStructuredBuffer<float3> particleVelocities;
RWStructuredBuffer<float> particleDensities;
RWStructuredBuffer<float3> particleForces;

// Buffers da grelha espacial
RWStructuredBuffer<int> spatialGrid;
RWStructuredBuffer<int> spatialGridCount;
RWStructuredBuffer<int> particleNeighbors;

// Parâmetros
uint particleCount;
uint spatialGridSizeX;
uint spatialGridSizeY;
uint spatialGridSizeZ;
float dt;
float smoothingRadius;
float collisionRadius;
float targetDensity;
float pressureMultiplier;
float viscosityStrength;
float stiffness;
float damping;
uint maxParticlesPerCell;
float3 simulationBoundsMin;
float3 simulationBoundsMax;

// Parâmetros booleanos para int (bool em constant buffers no HLSL pode causar problemas)
uint enableCollisions;
uint enableSPH;

// Funções auxiliares
uint GetGridIndex(int3 cell)
{
    return cell.x + cell.y * spatialGridSizeX + cell.z * spatialGridSizeX * spatialGridSizeY;
}

int3 WorldToGrid(float3 worldPos)
{
    int3 cell;
    cell.x = clamp((int)((worldPos.x - simulationBoundsMin.x) / collisionRadius), 0, (int)spatialGridSizeX - 1);
    cell.y = clamp((int)((worldPos.y - simulationBoundsMin.y) / collisionRadius), 0, (int)spatialGridSizeY - 1);
    cell.z = clamp((int)((worldPos.z - simulationBoundsMin.z) / collisionRadius), 0, (int)spatialGridSizeZ - 1);
    return cell;
}

// Funções kernel SPH padrão (Poly6 para densidade, Spiky para pressão, kernel de Viscosidade)
float Poly6Kernel(float distance, float radius)
{
    if (distance >= radius) return 0.0;
    
    float pi = 3.14159265359;
    float h = radius;
    float h2 = h * h;
    float h9 = h * h * h * h * h * h * h * h * h; // h^9 sem pow()
    float value = h2 - distance * distance;
    return (315.0 / (64.0 * pi * h9)) * value * value * value;
}

float SpikyKernelGradient(float distance, float radius)
{
    if (distance >= radius) return 0.0;
    
    float pi = 3.14159265359;
    float h = radius;
    float h6 = h * h * h * h * h * h; // h^6 sem pow()
    float value = h - distance;
    return (45.0 / (pi * h6)) * value * value;
}

float ViscosityKernelLaplacian(float distance, float radius)
{
    if (distance >= radius) return 0.0;
    
    float pi = 3.14159265359;
    float h = radius;
    float h6 = h * h * h * h * h * h; // h^6 sem pow()
    return (45.0 / (pi * h6)) * (h - distance);
}

// Construir grelha espacial para pesquisa rápida de vizinhos
[numthreads(8, 8, 4)]
void BuildSpatialGrid(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;
    uint z = id.z;
    
    if (x >= spatialGridSizeX || y >= spatialGridSizeY || z >= spatialGridSizeZ) 
        return;
    
    uint gridIndex = GetGridIndex(int3((int)x, (int)y, (int)z));
    
    // Limpar contagem para esta célula
    uint baseIndex = gridIndex * maxParticlesPerCell;
    for (uint i = 0; i < maxParticlesPerCell; i++)
    {
        spatialGrid[baseIndex + i] = -1;
    }
    spatialGridCount[gridIndex] = 0;
}

// Encontrar vizinhos para cada partícula
[numthreads(256, 1, 1)]
void FindNeighbors(uint3 id : SV_DispatchThreadID)
{
    uint particleIdx = id.x;
    if (particleIdx >= particleCount) 
        return;
    
    float3 pos = particlePositions[particleIdx];
    int3 cell = WorldToGrid(pos);
    
    int neighborCount = 0;
    uint baseNeighborIndex = particleIdx * 64;
    
    // Verificar célula atual e células vizinhas (região 3x3x3)
    for (int dx = -1; dx <= 1; dx++)
    {
        for (int dy = -1; dy <= 1; dy++)
        {
            for (int dz = -1; dz <= 1; dz++)
            {
                int3 neighborCell = cell + int3(dx, dy, dz);
                
                // Verificar limites
                if (neighborCell.x < 0 || neighborCell.x >= (int)spatialGridSizeX ||
                    neighborCell.y < 0 || neighborCell.y >= (int)spatialGridSizeY ||
                    neighborCell.z < 0 || neighborCell.z >= (int)spatialGridSizeZ)
                    continue;
                
                uint gridIndex = GetGridIndex(neighborCell);
                int count = spatialGridCount[gridIndex];
                uint baseGridIndex = gridIndex * maxParticlesPerCell;
                
                // Verificar todas as partículas nesta célula
                for (int i = 0; i < count && neighborCount < 64; i++)
                {
                    int otherIdx = spatialGrid[baseGridIndex + i];
                    
                    if (otherIdx != (int)particleIdx && otherIdx >= 0)
                    {
                        // Verificar se está dentro do raio de suavização
                        float3 otherPos = particlePositions[otherIdx];
                        float distance = length(pos - otherPos);
                        
                        if (distance < smoothingRadius * 1.5f)
                        {
                            particleNeighbors[baseNeighborIndex + neighborCount] = otherIdx;
                            neighborCount++;
                        }
                    }
                }
            }
        }
    }
    
    // Marcar fim da lista de vizinhos
    if (neighborCount < 64)
        particleNeighbors[baseNeighborIndex + neighborCount] = -1;
}

// Calcular densidade usando o kernel Poly6
[numthreads(256, 1, 1)]
void ComputeDensity(uint3 id : SV_DispatchThreadID)
{
    uint particleIdx = id.x;
    if (particleIdx >= particleCount) 
        return;
    
    float3 pos = particlePositions[particleIdx];
    float density = 0.0f;
    
    uint baseNeighborIndex = particleIdx * 64;
    
    // Somar contribuições de todos os vizinhos
    for (uint i = 0; i < 64; i++)
    {
        int neighborIdx = particleNeighbors[baseNeighborIndex + i];
        if (neighborIdx == -1) break;
        
        float3 neighborPos = particlePositions[neighborIdx];
        float distance = length(pos - neighborPos);
        
        if (distance < smoothingRadius)
        {
            density += Poly6Kernel(distance, smoothingRadius);
        }
    }
    
    // Adicionar contribuição própria
    density += Poly6Kernel(0.0, smoothingRadius);
    
    particleDensities[particleIdx] = density;
}

// Calcular forças (pressão, viscosidade e colisões)
[numthreads(256, 1, 1)]
void ComputeForces(uint3 id : SV_DispatchThreadID)
{
    uint particleIdx = id.x;
    if (particleIdx >= particleCount) 
        return;
    
    float3 pos = particlePositions[particleIdx];
    float3 vel = particleVelocities[particleIdx];
    float density = particleDensities[particleIdx];
    
    float3 pressureForce = float3(0, 0, 0);
    float3 viscosityForce = float3(0, 0, 0);
    float3 collisionForce = float3(0, 0, 0);
    
    uint baseNeighborIndex = particleIdx * 64;
    
    for (uint i = 0; i < 64; i++)
    {
        int neighborIdx = particleNeighbors[baseNeighborIndex + i];
        if (neighborIdx == -1) break;
        
        float3 neighborPos = particlePositions[neighborIdx];
        float3 neighborVel = particleVelocities[neighborIdx];
        float neighborDensity = particleDensities[neighborIdx];
        
        float3 offset = neighborPos - pos;
        float distance = length(offset);
        float3 direction = distance > 0.0001f ? offset / distance : float3(0, 1, 0);
        
        // Colisões entre partículas
        if (enableCollisions == 1 && distance < collisionRadius * 2.0f && distance > 0.0f)
        {
            // Força de mola para resposta a colisões
            float overlap = collisionRadius * 2.0f - distance;
            if (overlap > 0.0f)
            {
                float3 collisionDir = -direction;
                collisionForce += stiffness * overlap * collisionDir;
                
                // Amortecimento
                float3 relVel = vel - neighborVel;
                float velAlongNormal = dot(relVel, collisionDir);
                if (velAlongNormal > 0.0f)
                {
                    collisionForce += damping * velAlongNormal * collisionDir;
                }
            }
        }
        
        // Força de pressão SPH (usando equação do gás ideal: P = k(ρ - ρ₀))
        if (enableSPH == 1 && distance < smoothingRadius && distance > 0.0f)
        {
            // Pressão da diferença de densidade
            float pressure_i = pressureMultiplier * (density - targetDensity);
            float pressure_j = pressureMultiplier * (neighborDensity - targetDensity);
            float sharedPressure = pressure_i + pressure_j;
            
            // Usar kernel Spiky para gradiente de pressão
            pressureForce += sharedPressure * SpikyKernelGradient(distance, smoothingRadius) * direction;
            
            // Força de viscosidade SPH
            viscosityForce += (neighborVel - vel) * ViscosityKernelLaplacian(distance, smoothingRadius);
        }
    }
    
    // Aplicar multiplicador de força de viscosidade
    viscosityForce *= viscosityStrength;
    
    // Combinar todas as forças
    particleForces[particleIdx] = pressureForce + viscosityForce + collisionForce;
}

// Aplicar forças às velocidades
[numthreads(256, 1, 1)]
void ApplyForces(uint3 id : SV_DispatchThreadID)
{
    uint particleIdx = id.x;
    if (particleIdx >= particleCount) 
        return;
    
    // Aplicar forças à velocidade
    float3 force = particleForces[particleIdx];
    particleVelocities[particleIdx] += force * dt;
    
    // Limpar força para o próximo frame
    particleForces[particleIdx] = float3(0, 0, 0);
}