// CGProject - Compute Shader para Interações entre Partículas (SPH & Colisões)
// Kernel para simulação de interações partícula-partícula via SPH (Smoothed Particle Hydrodynamics)
// e deteção/resolução de colisões entre partículas

#pragma kernel BuildSpatialGrid
#pragma kernel FindNeighbors
#pragma kernel ComputeDensity
#pragma kernel ComputeForces
#pragma kernel ApplyForces

// Buffers estruturados para dados das partículas
RWStructuredBuffer<float3> particlePositions;   // Posições das partículas
RWStructuredBuffer<float3> particleVelocities;  // Velocidades das partículas
RWStructuredBuffer<float> particleDensities;    // Densidades calculadas via SPH
RWStructuredBuffer<float3> particleForces;      // Forças acumuladas por partícula

// Buffers para grelha espacial otimizada
RWStructuredBuffer<int> spatialGrid;            // Grelha espacial com índices de partículas
RWStructuredBuffer<int> spatialGridCount;       // Contagem de partículas por célula
RWStructuredBuffer<int> particleNeighbors;      // Lista de vizinhos para cada partícula

// Parâmetros de simulação configuráveis via script C#
int particleCount;              // Número total de partículas
int spatialGridSizeX;           // Dimensão X da grelha espacial
int spatialGridSizeY;           // Dimensão Y da grelha espacial
int spatialGridSizeZ;           // Dimensão Z da grelha espacial
float dt;                       // Passo temporal (delta time)
float smoothingRadius;          // Raio de suavização para kernels SPH
float collisionRadius;          // Raio de colisão entre partículas
float targetDensity;            // Densidade alvo para cálculo de pressão
float pressureMultiplier;       // Multiplicador da força de pressão
float viscosityStrength;        // Intensidade da força de viscosidade
float stiffness;                // Rigidez para resolução de colisões
float damping;                  // Amortecimento para resolução de colisões
int maxParticlesPerCell;        // Máximo de partículas por célula da grelha
float3 simulationBoundsMin;     // Limite mínimo do volume de simulação
float3 simulationBoundsMax;     // Limite máximo do volume de simulação

// NOTA: Parâmetros booleanos convertidos para int (bool em constant buffers do HLSL pode causar problemas)
int enableCollisions;           // Ativa/desativa colisões entre partículas (0=false, 1=true)
int enableSPH;                  // Ativa/desativa cálculo SPH de densidade (0=false, 1=true)

/// <summary>
/// Calcula índice linear numa grelha espacial 3D
/// </summary>
/// <param name="cell">Coordenadas (x,y,z) da célula</param>
/// <returns>Índice linear correspondente</returns>
int GetGridIndex(int3 cell)
{
    return cell.x + cell.y * spatialGridSizeX + cell.z * spatialGridSizeX * spatialGridSizeY;
}

/// <summary>
/// Converte coordenadas mundiais para coordenadas de grelha espacial
/// </summary>
/// <param name="worldPos">Posição no espaço mundial</param>
/// <returns>Coordenadas (x,y,z) da célula da grelha</returns>
int3 WorldToGrid(float3 worldPos)
{
    int3 cell;
    cell.x = clamp((int)((worldPos.x - simulationBoundsMin.x) / collisionRadius), 0, spatialGridSizeX - 1);
    cell.y = clamp((int)((worldPos.y - simulationBoundsMin.y) / collisionRadius), 0, spatialGridSizeY - 1);
    cell.z = clamp((int)((worldPos.z - simulationBoundsMin.z) / collisionRadius), 0, spatialGridSizeZ - 1);
    return cell;
}

// Funções de Kernel SPH padrão

/// <summary>
/// Kernel Poly6 para cálculo de densidade (suavização)
/// </summary>
/// <param name="distance">Distância entre partículas</param>
/// <param name="radius">Raio de suavização (smoothing radius)</param>
/// <returns>Valor do kernel na distância especificada</returns>
float Poly6Kernel(float distance, float radius)
{
    if (distance >= radius) return 0.0;
    
    float pi = 3.14159265359;
    float h = radius;
    float h2 = h * h;
    float h9 = pow(h, 9);
    float value = h2 - distance * distance;
    return (315.0 / (64.0 * pi * h9)) * value * value * value;
}

/// <summary>
/// Kernel Spiky para cálculo do gradiente de pressão
/// </summary>
/// <param name="distance">Distância entre partículas</param>
/// <param name="radius">Raio de suavização</param>
/// <returns>Valor do gradiente do kernel na distância especificada</returns>
float SpikyKernelGradient(float distance, float radius)
{
    if (distance >= radius) return 0.0;
    
    float pi = 3.14159265359;
    float h = radius;
    float h6 = pow(h, 6);
    float value = h - distance;
    return (45.0 / (pi * h6)) * value * value;
}

/// <summary>
/// Kernel para cálculo do Laplaciano de viscosidade
/// </summary>
/// <param name="distance">Distância entre partículas</param>
/// <param name="radius">Raio de suavização</param>
/// <returns>Valor do Laplaciano do kernel na distância especificada</returns>
float ViscosityKernelLaplacian(float distance, float radius)
{
    if (distance >= radius) return 0.0;
    
    float pi = 3.14159265359;
    float h = radius;
    float h6 = pow(h, 6);
    return (45.0 / (pi * h6)) * (h - distance);
}

/// <summary>
/// Kernel: Constrói a grelha espacial para otimização
/// Configuração: 8x8x4 threads por grupo de threads
/// </summary>
[numthreads(8, 8, 4)]
void BuildSpatialGrid(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;
    uint z = id.z;
    
    // Verifica limites da grelha espacial
    if (x >= spatialGridSizeX || y >= spatialGridSizeY || z >= spatialGridSizeZ) 
        return;
    
    int gridIndex = GetGridIndex(int3(x, y, z));
    
    // Limpa célula da grelha espacial
    int baseIndex = gridIndex * maxParticlesPerCell;
    for (int i = 0; i < maxParticlesPerCell; i++)
    {
        spatialGrid[baseIndex + i] = -1; // -1 indica célula vazia
    }
    spatialGridCount[gridIndex] = 0;
}

/// <summary>
/// Kernel: Encontra partículas vizinhas para cada partícula
/// Configuração: 256 threads por grupo (otimizado para muitas partículas)
/// </summary>
[numthreads(256, 1, 1)]
void FindNeighbors(uint3 id : SV_DispatchThreadID)
{
    uint particleIdx = id.x;
    if (particleIdx >= particleCount) 
        return;
    
    float3 pos = particlePositions[particleIdx];
    int3 cell = WorldToGrid(pos);
    
    int neighborCount = 0;
    int baseNeighborIndex = particleIdx * 64; // Cada partícula pode ter até 64 vizinhos
    
    // Verifica célula atual e células próximas (região 3x3x3)
    for (int dx = -1; dx <= 1; dx++)
    {
        for (int dy = -1; dy <= 1; dy++)
        {
            for (int dz = -1; dz <= 1; dz++)
            {
                int3 neighborCell = cell + int3(dx, dy, dz);
                
                // Verifica limites da grelha espacial
                if (neighborCell.x < 0 || neighborCell.x >= spatialGridSizeX ||
                    neighborCell.y < 0 || neighborCell.y >= spatialGridSizeY ||
                    neighborCell.z < 0 || neighborCell.z >= spatialGridSizeZ)
                    continue;
                
                int gridIndex = GetGridIndex(neighborCell);
                int count = spatialGridCount[gridIndex];
                int baseGridIndex = gridIndex * maxParticlesPerCell;
                
                // Verifica todas as partículas nesta célula
                for (int i = 0; i < count && neighborCount < 64; i++)
                {
                    int otherIdx = spatialGrid[baseGridIndex + i];
                    
                    // Exclui a própria partícula e índices inválidos
                    if (otherIdx != particleIdx && otherIdx >= 0)
                    {
                        // Verifica se está dentro do raio de suavização
                        float3 otherPos = particlePositions[otherIdx];
                        float distance = length(pos - otherPos);
                        
                        // Usa raio ligeiramente maior para busca de partículas próximas (margem de segurança)
                        if (distance < smoothingRadius * 1.5f)
                        {
                            particleNeighbors[baseNeighborIndex + neighborCount] = otherIdx;
                            neighborCount++;
                        }
                    }
                }
            }
        }
    }
    
    if (neighborCount < 64)
        particleNeighbors[baseNeighborIndex + neighborCount] = -1;
}

/// <summary>
/// Kernel: Calcula densidade para cada partícula usando SPH
/// Configuração: 256 threads por grupo (otimizado para muitas partículas)
/// </summary>
[numthreads(256, 1, 1)]
void ComputeDensity(uint3 id : SV_DispatchThreadID)
{
    uint particleIdx = id.x;
    if (particleIdx >= particleCount) 
        return;
    
    float3 pos = particlePositions[particleIdx];
    float density = 0.0f;
    
    int baseNeighborIndex = particleIdx * 64;
    
    // Soma contribuições de todas as neighbor particles
    for (int i = 0; i < 64; i++)
    {
        int neighborIdx = particleNeighbors[baseNeighborIndex + i];
        if (neighborIdx == -1) break;
        
        float3 neighborPos = particlePositions[neighborIdx];
        float distance = length(pos - neighborPos);
        
        if (distance < smoothingRadius)
        {
            density += Poly6Kernel(distance, smoothingRadius);
        }
    }
    
    // Adiciona contribuição própria (self-contribution)
    density += Poly6Kernel(0.0, smoothingRadius);
    
    particleDensities[particleIdx] = density;
}

/// <summary>
/// Kernel: Calcula forças totais (pressão, viscosidade e colisões) para cada partícula
/// Configuração: 256 threads por grupo (otimizado para muitas partículas)
/// </summary>
[numthreads(256, 1, 1)]
void ComputeForces(uint3 id : SV_DispatchThreadID)
{
    uint particleIdx = id.x;
    if (particleIdx >= particleCount) 
        return;
    
    float3 pos = particlePositions[particleIdx];
    float3 vel = particleVelocities[particleIdx];
    float density = particleDensities[particleIdx];
    
    // Inicializa acumuladores de força
    float3 pressureForce = float3(0, 0, 0);
    float3 viscosityForce = float3(0, 0, 0);
    float3 collisionForce = float3(0, 0, 0);
    
    int baseNeighborIndex = particleIdx * 64;
    
    // Processa todas as neighbor particles
    for (int i = 0; i < 64; i++)
    {
        int neighborIdx = particleNeighbors[baseNeighborIndex + i];
        if (neighborIdx == -1) break;
        
        float3 neighborPos = particlePositions[neighborIdx];
        float3 neighborVel = particleVelocities[neighborIdx];
        float neighborDensity = particleDensities[neighborIdx];
        
        float3 offset = neighborPos - pos;
        float distance = length(offset);
        float3 direction = distance > 0.0001f ? offset / distance : float3(0, 1, 0);
        
        // COLISÕES PARTÍCULA-PARTÍCULA (se ativadas)
        if (enableCollisions == 1 && distance < collisionRadius * 2.0f && distance > 0.0f)
        {
            // Força de mola para resposta a colisões
            float overlap = collisionRadius * 2.0f - distance;
            if (overlap > 0.0f)
            {
                float3 collisionDir = -direction; // Direção oposta à colisão
                collisionForce += stiffness * overlap * collisionDir;
                
                // Amortecimento baseado na velocidade relativa
                float3 relVel = vel - neighborVel;
                float velAlongNormal = dot(relVel, collisionDir);
                if (velAlongNormal > 0.0f)
                {
                    collisionForce += damping * velAlongNormal * collisionDir;
                }
            }
        }
        
        // Forças SPH
        if (enableSPH == 1 && distance < smoothingRadius && distance > 0.0f)
        {
            // Pressão baseada na diferença de densidade (equação de gás ideal: P = k(ρ - ρ₀))
            float pressure_i = pressureMultiplier * (density - targetDensity);
            float pressure_j = pressureMultiplier * (neighborDensity - targetDensity);
            float sharedPressure = pressure_i + pressure_j;
            
            // Força de pressão (usa gradiente do kernel Spiky)
            pressureForce += sharedPressure * SpikyKernelGradient(distance, smoothingRadius) * direction;
            
            // Força de viscosidade (suaviza diferenças de velocidade)
            viscosityForce += (neighborVel - vel) * ViscosityKernelLaplacian(distance, smoothingRadius);
        }
    }
    
    // Aplica multiplicador de intensidade de viscosidade
    viscosityForce *= viscosityStrength;
    
    // Combina todas as forças calculadas
    particleForces[particleIdx] = pressureForce + viscosityForce + collisionForce;
}

/// <summary>
/// Kernel: Aplica forças acumuladas às velocidades das partículas
/// Configuração: 256 threads por grupo (otimizado para muitas partículas)
/// </summary>
[numthreads(256, 1, 1)]
void ApplyForces(uint3 id : SV_DispatchThreadID)
{
    uint particleIdx = id.x;
    if (particleIdx >= particleCount) 
        return;
    
    // Aplica forças à velocidade (integração explícita)
    float3 force = particleForces[particleIdx];
    particleVelocities[particleIdx] += force * dt;
    
    // Limpa buffer de forças para o próximo passo temporal
    particleForces[particleIdx] = float3(0, 0, 0);
}